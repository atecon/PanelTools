<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="PanelTools" needs-panel-data="true" minver="2021a">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.3</version>
<date>2022-03-30</date>
<description>Collection of tools for handling panel data</description>
<tags>C10</tags>
<help>
# PanelTools
Collection of (hopefully) useful functions for dealing with panel datasets.


# Public functions

## pcum(const series y)
Compute cumulated value for each panel unit.

Parameters
    y   - series, target series;

Returns
Series with cumulated sum for each cross-sectional unit. NAs are replaced by
zero before cumulating.


## pmode(const series y)
Compute most frequent value for each cross-sectional unit.

Parameters
    y   - series, target series

Returns
Series with most frequent values for each cross-sectional unit. NA values are
ignored. If all values are NA for a unit, a series consisting only NA values is
returned for that unit.


## pfirst(const series y)
Compute first valid value for each panel unit.

Parameters
    y   - series, target series

Returns
Series with the first valid value of &quot;y&quot; for each cross-sectional unit. If no
valid values exists for a unit, NA is returned.


## plast(const series y)
Compute last valid value for each panel unit.

Parameters
    y   - series, target series

Returns
Series with the last valid value of &quot;y&quot; for each cross-sectional unit. If no
valid values exists for a unit, NA is returned.


## pquantile(const series y, const scalar value &quot;p-th quantile&quot;)
Compute the p-th quantile for each unit.

Parameters
    y     - series, target series
    value - scalar, p-th quantile; must be in the range 0 &lt; value &lt; 1

Returns
Series with the p-th quantile for each cross-sectional unit. NA values are
ignored. If all values are NA for a unit, a series consisting only NA values is
returned for that unit.


## pxmean(const series y)
Compute mean value of &quot;y&quot; across all units per
time period. Missing values are ignored for computing the mean.

Parameters
    y        - series, target series
Returns
Series with the mean value value across all units per observation. NA values are
completely ignored and are not counted.


## pxfraction(const series y, const scalar value &quot;Value to search&quot;,
             const bool fraction[FALSE] &quot;Fraction instead of total number&quot;)
Compute the total number of observations of &quot;value&quot; in &quot;y&quot; across all units per
time period. Missing values are completely ignored.

Parameters
    y        - series, target series
    value    - scalar, Value to search in &quot;y&quot;
    fraction - bool, if TRUE (=1) compute the fraction of observations taking the
               value &quot;value&quot;, if FALSE (=0, default) compute the number of
               observations instead.

Returns
Series with the respective value across all units per observation. NA values are
completely ignored and are not counted.


## ppolyfit(const series y, const int order[1::])
Fits a polynomial trend of order &quot;order&quot; to the input series &quot;y&quot; using OLS for each cross-sectional unit separately. This function mimics gretl's built-in function polyfit() which works only for time-series data correctly before version 2021c.

Parameters
    y        - series, target series
    order    - integer, Order of the polynomial trend

Returns
Series of fitted values for each unit. In case 'y' has missing values for a
specific unit, for this unit a time-series with NAs is returned.


## panelinfo()
Compute basic information about the panel dimension.

Returns
Nothing.


## mpmean(const matrix m, const int N)
Compute vector of mean values of &quot;m&quot; for each cross-sectional unit. Matrix
equivalent to gretl's built-in pmean() function. Missing values are ignored.

Parameters
    m        - matrix, Column vector of dimension T*N
    N        - int, Number of cross-sectional units

Returns
Matrix of stacked time-series of means of &quot;m&quot; for each unit. NA values are
completely ignored.



## fe_estimator (const matrix y, const matrix X, const int N[1::])
Matrix-based equivalent of gretl's built-in fixed-effect panel estimator
(see 'help panel'). Currently no inference is done.

Parameters
    y        - matrix, Column vector of stacked time-series
    X        - matrix, Matrix of regressors of stacked time-series
    N        - integer, Number of cross-sectional units

Returns
Bundle object comprising both point estimates of coefficients (key: &quot;coeff&quot;) and
estimated fixed-effects stored as stacked time-series (key: &quot;ahat&quot;).


## pols_estimator (const matrix y, const matrix X, const int N[1::])
Matrix-based equivalent of gretl's built-in pooled ols function (see 'help panel').
Currently no inference is done.

Parameters
    y        - matrix, Column vector of stacked time-series
    X        - matrix, Matrix of regressors of stacked time-series
    N        - integer, Number of cross-sectional units

Returns
Bundle object comprising point estimates of coefficients (key: &quot;coeff&quot;).


## pfcast (const matrix X, const bundle Model, const bool verbose[FALSE])
Compute static predictions for a given model. For the fixed-effects, the fixed-effects are
added. This is the same treatment as gretl does for the panel fixed-effects model when
applying the 'fcast' command.

Parameters
    X        - matrix, Matrix of regressors of stacked time-series for test set.
    Model    - bundle, Model object holding information on estimation results
    verbose  - bool, print details (optional, default = FALSE)

Returns
Matrix of stacked forecasts. &quot;N&quot; stacked time-series of length &quot;horizon&quot;. The parameter
&quot;horizon&quot; is internally determined by the input dimension of &quot;X&quot; and the number of
cross-sectional units &quot;N&quot; as specified in the &quot;Model&quot; bundle.


## mean_robust (const matrix X)
Works as gretl's built-in function meanc(). Compute mean values for each column even in case of missing values.

Parameters
    X        - matrix, Matrix with data and possibly missing values

Returns
Row vector with mean values for each column.

## sdc_robust (const matrix X)
Works as gretl's built-in function sdc(). Compute standard deviation for each column even in case of missing values.

Parameters
    X        - matrix, Matrix with data and possibly missing values

Returns
Row vector with standard deviation values for each column.


# Changelog
v0.3 (03-2022)
- Add new functions mpmean(), meanc_robust() and sdc_robust()
- Add new function fe_estimator() for estimating a fixed-effects model using matrices as inputs (no inference supported, yet)
- Add new function pols_estimator() for estimating a pooled-OLS model using matrices as inputs (no inference supported, yet)
- Add new function pfcast() for computing predictions using some supported panel model using matrices.

v0.2 (07-2021)
- Add new ppolyfit() function

v0.1 (07-2021)
- Initial version
</help>
<depends count="1">
extra </depends>
<gretl-function name="pcum" type="series">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute cumulated value for each panel unit.
return: series, Cumulated sum for each cross-sectional unit. */
set skip_missing off
errorif($datatype != 3, &quot;Only for panel dataset.&quot;)
matrix m = mshape({y}, $pd, ($nobs / $pd))
# Columns with missing values are ignored. Hence, we replace NAs before
m = ok(m) ? m : 0
series ret = vec(cum(m))
set skip_missing on
string desc = get_description(&quot;pcum&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="pquantile" type="series">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="value" type="scalar" const="true">
<description>p-th quantile</description>
  </param>
 </params>
<code>/* Compute the p-th quantile for each unit. Missing values are ignored
for computation of the quantile.
return: series, p-th quantile for each cross-sectional unit. */
errorif($datatype != 3, &quot;Only for panel dataset.&quot;)
errorif(value &lt;= 0 || value &gt;= 1.0, &quot;Parameter 'value' must be in the range '0 &lt; value &lt; 1'.&quot;)
set skip_missing off
scalar N = $nobs / $pd
matrix m = mshape({y}, $pd, N)
matrix mat = mshape(NA, N, 1)
if sum(missing(m))
  # Columns may have missing values and quantile() breaks down if
  # a column only consists of NA values.
  loop i=1..N
    matrix mask = ok(m[,i])
    matrix vals = selifr(m[,i], mask)
    if nelem(vals)
      mat[i] = quantile(vals, value) # scalar value
    endif
  endloop
else
  # faster version
  matrix mat = quantile(m, value)
endif
set skip_missing on
series ret = pexpand(vec(mat))
string desc = get_description(&quot;pquantile&quot;, argname(y), value)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="pxfraction" type="series">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="value" type="scalar" const="true">
<description>Value to search</description>
  </param>
  <param name="fraction" type="bool" default="0" const="true">
<description>Fraction instead of total number</description>
  </param>
 </params>
<code>/* Compute the total number of observations of &quot;value&quot; in &quot;y&quot; across
all units per time period. Missing values are completely ignored.
If fraction is TRUE, the fraction of observations of &quot;value&quot; in &quot;y&quot; across
each unit per time period is computed, instead. */
errorif($datatype != 3, &quot;Only for panel dataset.&quot;)
errorif(!ok(value), &quot;You can only search for a valid 'value'.&quot;)
scalar N = $nobs / $pd
series z = (y == value)
if fraction
  matrix x = aggregate(z, time, mean)[, 3]
else
  matrix x = aggregate(z, time, sum)[, 3]
endif
x = ok(x) ? x : 0
x = ones($pd, N) .* x
series ret = vec(x)
string desc = get_description(&quot;pxfraction&quot;, argname(y), value)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="pfirst" type="series">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute first valid value for each panel unit. Expand this constant value for each unit to a series. */
series ret = helper_pfirst_plast(y, FALSE)
string desc = get_description(&quot;pfirst&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="plast" type="series">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute last valid value for each panel unit. Expand this constant value for each unit to a series. */
series ret = helper_pfirst_plast(y, TRUE)
string desc = get_description(&quot;plast&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="pmode" type="series">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute most frequent value for each cross-sectional unit.
return: series, constant value for each cross-sectional unit.
Dependency: extra.gfn */
errorif($datatype != 3, &quot;Only for panel dataset.&quot;)
errorif(!nobs(y), &quot;No valid observations.&quot;)
set skip_missing off
scalar N = $nobs / $pd
matrix m = mshape({y}, $pd, N)
matrix mat = mshape(NA, N, 1)
loop i=1..N
  mat[i] = onemode(m[,i])[1]
endloop
set skip_missing on
series ret = pexpand(mat)
string desc = get_description(&quot;pmode&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="pxmean" type="series">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute mean for each time-period across all cross-sectional units. */
errorif($datatype != 3, &quot;Only for panel dataset.&quot;)
series ret = pxsum(y) / pxnobs(y)
string desc = get_description(&quot;pxmean&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="panelinfo" type="void">
<code>printf &quot;\nINFO: Information on panel dimensions:\n&quot;
printf &quot;Number of cross-sectional units = %d\n&quot;, ($nobs / $pd)
printf &quot;Number of time-dimension %d observations\n\n&quot;, $pd
</code>
</gretl-function>
<gretl-function name="ppolyfit" type="series">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="order" type="int" min="1" const="true"/>
 </params>
<code>/* Fits a polynomial trend of order &quot;order&quot; to the input series &quot;y&quot; using the method of orthogonal polynomials for each cross-sectional unit separately.
This function mimics gretl's built-in function polyfit() which works only for time-series data correctly before version 2021c.
return: series, fitted values for each unit. In case 'y' has missing values for a specific unit, for this unit a time-series with NAs is returned.
Function thankfully brought to you Jack Lucchetti.
*/
errorif($datatype != 3, &quot;Only for panel dataset. Try to use the polyfit() function, instead.&quot;)
if sum(missing(y))
  print &quot;WARNING: Series 'y' has missing values. Fitted values for some unit(s) will be NA.&quot;
endif
scalar T = $pd
scalar N = $nobs / T
set skip_missing off
matrix E
matrix Y = mshape({y}, T, N)
trend = seq(0, (T - 1))'
matrix X = 1 ~ trend .^ (seq(1, order))
mols(Y, X, &amp;E)
series ret = vec(Y - E)
string desc = get_description(&quot;ppolyfit&quot;, argname(y), order)
setinfo ret --description=&quot;@desc&quot;
set skip_missing on
return ret
</code>
</gretl-function>
<gretl-function name="mpmean" type="matrix">
 <params count="2">
  <param name="m" type="matrix"/>
  <param name="N" type="int" const="true"/>
 </params>
<code>/* Compute vector of mean values of the column vector &quot;m&quot; for each
cross-sectional unit. Missing values are automatically handled.
Matrix equivalent to gretl's built-in pmean() function.
return: matrix, Stacked time-series of means of &quot;m&quot;. */
set skip_missing off
scalar T = rows(m) / N
matrix x = mshape(NA, (N * T), cols(m))
matrix unity = ones(T, N)
loop i=1..cols(m)
  x[,i] = vec( unity .* meanc_robust(mshape(m[,i], T, N)) )
endloop
set skip_missing on
return x
</code>
</gretl-function>
<gretl-function name="fe_estimator" type="bundle">
 <params count="3">
  <param name="y" type="matrix" const="true"/>
  <param name="X" type="matrix" const="true"/>
  <param name="N" type="int" min="1" const="true">
<description>Number of cross-sectional units</description>
  </param>
 </params>
<code>/* Fixed-effects estimation using matrices.
return: bundle, Model output. */
set skip_missing off
matrix mask
bundle B = model_bundle_basics(y, X, N)
string B.estimator = &quot;fixed_effects&quot;
matrix mybar = mpmean(y, N)
matrix mxbar = mpmean(X, N)
matrix endog = y .- mybar
matrix exog = X .- mxbar
print &quot;INFO: Drop eventual constant series from list of selected features.&quot;
scalar nc = cols(exog)
matrix exog = drop_constants(exog, &amp;mask)
print_number_of_droppped_cols(nc, cols(exog))
mxbar = selifc(mxbar, mask)
# As some columns may be dropped, we need to update B.parnames
B.parnames = mask_string_array(B.parnames, mask)
catch matrix B.coeff = mols(endog, exog)
B.error = $error
if B.error
  return B
endif
rnameset(B.coeff, B.parnames)
matrix B.xmat = parnames_to_matrix(X, B.parnames)
matrix B.ahat = get_ahat(mybar, mxbar, B)
matrix B.yhat = B.ahat + B.xmat * B.coeff
matrix B.uhat = y - B.yhat
matrix B.rsq = rsq_overall(y, B.yhat)
set skip_missing on
return B
</code>
</gretl-function>
<gretl-function name="pols_estimator" type="bundle">
 <params count="3">
  <param name="y" type="matrix" const="true"/>
  <param name="X" type="matrix" const="true"/>
  <param name="N" type="int" min="1" const="true">
<description>Number of cross-sectional units</description>
  </param>
 </params>
<code>/* Pooled OLS estimation using matrices without inference.
Equivalent to gretl's &quot;panel&quot; command with the option &quot;--pooled&quot;.
return: bundle, Model output. */
bundle B = model_bundle_basics(y, X, N)
string B.estimator = &quot;ols&quot;
catch matrix B.coeff = mols(y, X)
B.error = $error
if B.error
  return B
endif
rnameset(B.coeff, cnameget(X))
return B
</code>
</gretl-function>
<gretl-function name="pfcast" type="matrix">
 <params count="3">
  <param name="xtest" type="matrix" const="true">
<description>Values of test set</description>
  </param>
  <param name="Model" type="bundle" const="true">
<description>Model object</description>
  </param>
  <param name="verbose" type="bool" default="0" const="true"/>
 </params>
<code>/* Compute static point forecasts for a given model.
return: matrix, Stacked &quot;horizon&quot; by &quot;N&quot; time-series of forecasts. */
errorif(rows(Model.coeff) != cols(xtest), &quot;Number of variables does not match length of coefficient vector.&quot;)
scalar horizon = rows(xtest) / Model.N
if verbose
  print &quot;INFO: Compute predictions.&quot;
endif
matrix fc = xtest * Model.coeff
if Model.estimator == &quot;fixed_effects&quot;  # add fixed-effects
  fc = mshape(fc, horizon, Model.N)
  fc = fc .+ mshape(Model.ahat, Model.T, Model.N)[1,]  # N by 1
endif
if verbose
  print &quot;INFO: Finished model estimation.&quot;
endif
return vec(fc)
</code>
</gretl-function>
<gretl-function name="meanc_robust" type="matrix">
 <params count="1">
  <param name="X" type="matrix" const="true"/>
 </params>
<code>/* Compute mean values for each column even in case of missing values. */
matrix B = ok(X)
return sumc(B ? X : 0) ./ sumc(B)
</code>
</gretl-function>
<gretl-function name="sdc_robust" type="matrix">
 <params count="1">
  <param name="x" type="matrix" const="true"/>
 </params>
<code>/* Compute standard deviation in case of nan values in matrix. */
matrix m = ok(x)
matrix d = x .- meanc_robust(x)
return sqrt(sumc( (m ? d : 0 ).^2 ) ./ sumc(m))
</code>
</gretl-function>
<gretl-function name="helper_pfirst_plast" type="series" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="do_plast" type="bool" const="true"/>
 </params>
<code>/* Wrapper for pfirst() and plast()
return: series, respective values. */
errorif($datatype != 3, &quot;Only for panel dataset.&quot;)
set skip_missing off
scalar N = $nobs / $pd
matrix m = mshape({y}, $pd, N)
matrix ret = mshape(NA, N, 1)
loop i=1..N
  matrix mask = ok(m[,i])
  matrix vals = selifr(m[,i], mask)
  scalar idx = do_plast == TRUE ? rows(vals) : 1
  ret[i] = sum(mask) ? vals[idx] : NA
endloop
set skip_missing on
return pexpand(ret)
</code>
</gretl-function>
<gretl-function name="get_description" type="string" private="1">
 <params count="3">
  <param name="fname" type="string" const="true"/>
  <param name="yname" type="string" const="true"/>
  <param name="value" type="scalar"/>
 </params>
<code>/* Retrieve series' description.
return: string */
scalar value = !exists(value) ? 1 : value
bundle B = _( ppolyfit = sprintf(&quot;polynomial fit of %s (order=%d)&quot;, yname, value), pcum = sprintf(&quot;cumuluated values of %s&quot;, yname), pquantile = sprintf(&quot;quantile (q=%g) values of %s&quot;, value, yname), pxfraction = sprintf(&quot;cross-sectional fractions of %s (value=%g)&quot;, yname, value), pfirst = sprintf(&quot;first valid values of %s&quot;, yname), plast = sprintf(&quot;last valid values of %s&quot;, yname), pmode = sprintf(&quot;modes of %s&quot;, yname), pxmean = sprintf(&quot;cross-sectional means of %s&quot;, yname) )
return B[&quot;@fname&quot;]
</code>
</gretl-function>
<gretl-function name="get_ahat" type="matrix" private="1">
 <params count="3">
  <param name="mybar" type="matrix" const="true">
<description>Unit-specific mean of 'y'</description>
  </param>
  <param name="mxbar" type="matrix" const="true">
<description>Unit-specific means of 'x' per columns</description>
  </param>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Compute fixed-effects.
return: matrix, Column vector with fixed-effects as stacked time-series. */
mybar_values = vec(mshape(mybar, self.T, self.N)[1,]) # N by 1
# Extract vector of unit-specific mean values: N by k
matrix x = mshape(NA, self.N, cols(mxbar))
loop i=1..cols(mxbar)
  x[,i] = vec(mshape(mxbar[,i], self.T, self.N)[1,]) # only 1st row as constant
endloop
matrix ahat = mybar_values .- (x * self.coeff)
return vec(ones(self.T, self.N) .* ahat')
</code>
</gretl-function>
<gretl-function name="rsq_overall" type="scalar" private="1">
 <params count="2">
  <param name="y" type="matrix" const="true"/>
  <param name="yhat" type="matrix" const="true"/>
 </params>
<code>/* Compute the overall R^2 statistics as defined in Verbeek's textbook.
return: scalar, overall R^2 statistics */
scalar x = mcorr(y ~ yhat)[1,2]^2
return ok(x) ? x : 0
</code>
</gretl-function>
<gretl-function name="parnames_to_matrix" type="matrix" private="1">
 <params count="2">
  <param name="x" type="matrix" const="true"/>
  <param name="S" type="strings" const="true"/>
 </params>
<code>/* Compile a matrix of series based on an array of series names.
return: matrix, Including columns as named in 'S'. */
matrix R
strings xnames = cnameget(x)
strings Rnames
loop foreach i S
  matrix m = instrings(xnames, &quot;$i&quot;)
  if nelem(m)
    R ~= x[, m[1]]
    Rnames += &quot;$i&quot;
  endif
endloop
cnameset(R, Rnames)
return R
</code>
</gretl-function>
<gretl-function name="print_number_of_droppped_cols" type="void" private="1">
 <params count="2">
  <param name="before" type="int" min="0" const="true"/>
  <param name="after" type="int" min="0" const="true"/>
 </params>
<code>ndropped = before - after
if ndropped &gt; 0
  printf &quot;INFO: Dropped %d columns from feature list.\n&quot;, ndropped
endif
</code>
</gretl-function>
<gretl-function name="mask_string_array" type="strings" private="1">
 <params count="2">
  <param name="S" type="strings" const="true"/>
  <param name="mask" type="matrix"/>
 </params>
<code>/* Select from S only masked entries.
return: string array */
strings ret = array()
mask = vec(mask)
if sum(mask) == 0
  print &quot;WARNING: Matrix 'mask' has only zeros. Ignore.&quot;
  return ret
endif
if nelem(mask) == 0 || nelem(S) == 0
  print &quot;WARNING: Either matrix 'mask' or string array S has no valid entries. Ignore.&quot;
  return ret
endif
if nelem(mask) != nelem(S)
  print &quot;ERROR: String array must have the same dimension as vector. Return empty array&quot;
  return ret
endif
loop i=1..rows(mask)
  if mask[i] == TRUE
    ret += S[i]
  endif
endloop
return ret
</code>
</gretl-function>
<gretl-function name="model_bundle_basics" type="bundle" private="1">
 <params count="3">
  <param name="y" type="matrix" const="true"/>
  <param name="X" type="matrix" const="true"/>
  <param name="N" type="int" min="1" const="true">
<description>Number of cross-sectional units</description>
  </param>
 </params>
<code>/* Fill model bundle with basic information
return: bundle, basic initial information. */
bundle B
scalar B.N = N
scalar B.T = rows(y) / B.N # consider the case that y is sub-sampled
string B.depvar = nelem(cnameget(y)) ? cnameget(y)[1] : &quot;&quot;
strings B.parnames = cnameget(X)
scalar B.error = FALSE
return B
</code>
</gretl-function>
<gretl-function name="drop_constants" type="matrix" private="1">
 <params count="2">
  <param name="m" type="matrix" const="true"/>
  <param name="mask" type="matrixref" optional="true"/>
 </params>
<code>/* Drop columns which are constant over its entire length.
return: matrix, Columns which are not constant over its entire length. */
matrix mask = (sdc_robust(m) .!= 0)
return selifc(m, mask)
</code>
</gretl-function>
<sample-script>
clear
set verbose off
include PanelTools.gfn

open grunfeld.gdt --quiet

panelinfo()

series invest_pfirst = pfirst(invest)
series invest_plast = plast(invest)
series invest_pcum = pcum(invest)
series invest_pmode = pmode(invest)
series invest_pquantile = pquantile(invest, 0.5)

series invest_pxmean = pxmean(invest)
series invest_pxfraction = pxfraction(invest, min(invest), FALSE)
series invest_pxfraction_fraction = pxfraction(invest, min(invest), TRUE)

print invest invest_* -o --range=1:40

series invest_poly = ppolyfit(invest, 2)
print invest invest_poly -o --range=1:40
</sample-script>
</gretl-function-package>
</gretl-functions>
